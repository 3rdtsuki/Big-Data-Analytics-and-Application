目标：给定n篇文章，找相似度>k的文章对

Jaccard相似度：
$$
sim(a,b)=\frac{|a\cap b|}{|a\cup b|}
$$
距离=1-sim(a,b)

bit向量表示10010，每位代表一个单词

### Shingling：提高精度

k-shingle：将所有长度为k的短语切分出来，放进集合，可以保持词语顺序

形成{行：短语，列：文章}的稀疏bool矩阵

### 最小哈希：降低空间复杂度

压缩稀疏矩阵：设m个短语，n篇文章

|      | C1   | C2   |
| ---- | ---- | ---- |
| A    | 1    | 1    |
| B    | 0    | 1    |
| C    | 1    | 0    |
| D    | 0    | 0    |

假设进行k次最小哈希操作：

while(k--):

​	生成range[1,m]的随机数，记为索引

​	对每一篇文章，按索引从小到大顺序找到第一个非0的位置，作为该列的签名

​	这些签名构成长为n的列表

最终得到**k*n**的矩阵，每一列的相似度就是文章的相似度

假设两篇文章A类型的短语数量为a，...，则相似度为a/(a+b+c)

通过最小哈希得到的列表，一篇文章第一个非0的位置取到A类型的概率是a/(a+b+c)；在最终的矩阵中，某行两个数相同代表在这一趟最小哈希中，第一个非0的位置相同，在这个位置上有相同短语，即A类型

### 局部敏感哈希：降低时间复杂度

两篇文章至少一块被判相似就算相似。

假设两文章用minHash计算出相似度为30%，不能判为整体相似。将文章分成b块，每块r行去哈希，每行判定为相似的概率是30%，于是每块判为相似的概率是(30%)^r（r行全相似），每块不被判相似的概率是1-(30%)^r，所有块不被判相似的概率(1-(30%)^r)^b，至少一块被判相似的概率1-(1-(30%)^r)^b，这个值就定为两篇文章判定为相似的概率。

图像类似于
$$
y=\frac{1}{1+e^{-x}}
$$
x：minHash总相似度，y：两篇文章判定为相似的概率